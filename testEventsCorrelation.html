<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Events Correlation Test</title>
    <style>
        .content {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 80vw;
            height: 80vh;
        }

        header button {
            padding: 10px 20px;
        }
    </style>
</head>
<body>
<div id="root">
    <header>
        <button class="match-a-to-b">MATCH A TO B</button>
        <button class="match-b-to-a">MATCH B TO A</button>
        <button class="match-both">MATCH BOTH</button>
        <button class="match-dtw">MATCH DTW</button>
        <label>
            Number of deaths
            <input min="0" type="range" class="dtw-deaths">
            <span class="death-count">0</span>
        </label>
    </header>
    <div class="content">
        <svg width="100%" height="100%">

        </svg>
    </div>
</div>

<script src="d3.js"></script>
<script src="js/eventTypeVis.js"></script>
<script>

    const root = d3.select('#root');

    const svg = root.select('svg');

    const bounds = svg.node().getBoundingClientRect();

    const height = 100;

    const generateChart = (group_name, data, params = {}) => {
        params = {
            ...params,
            color: params.color || "black",
            offsetY: params.offsetY || 0
        }

        let group = svg.select('g#' + group_name)

        if (group.empty()) {
            group = svg
                .append('g')
                .attr('id', group_name)
                .attr('transform', `translate(0, ${params.offsetY})`)
        }

        let rect = group.select('rect.background');
        if (rect.empty()) {
            rect = group.append('rect')
                .attr('class', 'background')
                .attr('fill', 'white')
                .attr('stroke-width', 2)
                .attr('stroke', 'black')
                .attr('height', height)
                .attr('width', bounds.width)
        }

        let bar = group.select('rect.bar')
        if (bar.empty()) {
            bar = group.append('rect')
                .attr('class', 'bar')
                .attr('width', 2)
                .style('pointer-events', 'none')
                .attr('fill', 'black')
                .attr('height', height)
        }

        let pointGroup = group.select('g.points')
        if (pointGroup.empty()) {
            pointGroup = group.append('g')
                .attr('class', 'points')
                .attr('pointer-events', 'none')
        }

        let distanceScale = d3.scaleLinear()
            .domain([0, bounds.width])
            .range([0, bounds.width])

        const pointSel = pointGroup
            .selectAll('circle')
            .data(data)

        pointSel.enter()
            .append('circle')
            .merge(pointSel)
            .attr('fill', params.color)
            .attr('cx', d => d)
            .attr('cy', height / 2)
            .attr('r', 5)

        rect.on('mousemove', function () {
            const coordinates= d3.mouse(this);
            const x = coordinates[0];

            bar.style('visibility', 'visible')
                .attr('x', x)
        })

        rect.on('mouseout', function () {
            bar.style('visibility', 'hidden')
        })

        rect.on('mousedown', function() {
            const coordinates= d3.mouse(this);
            const x = coordinates[0];
            data.push(x);
            // data must be sorted even if insertion is done randomly
            data = data.sort((a, b) => a - b);
            generateChart(group_name, data, params)
        })

    };

    const dataA = [];
    const dataB = [];

    const getGroupOffset = (index = 0) => index * (height + 20);
    const getYMid = (index = 0) => getGroupOffset(index) + height / 2;
    const sd = new SimulationDistance();
    let dtw;

    const buildMatchingEvents = (deaths, datumSelector = d => d) => {
        const NA = dataA.length;
        const NB = dataB.length;
        // not possible with deaths
        if (dtw[deaths][NA][NB][0] === 1e9) {
            return {
                distance: 1e9,
                pairs: []
            }
        }
        const pairs = [];
        let d = deaths;
        let i = NA, j = NB, k = 0;
        while (i >= 1 && j >= 1) {
            const datumA = dataA[i - 1];
            const datumB = dataB[j - 1];
            const cost = Math.abs(datumSelector(datumA) - datumSelector(datumB));
            let matchPair = true;
            const pair = { a: i - 1, b: j - 1 }
            if (dtw[d][i - 1][j][2] + cost === dtw[d][i][j][k]) {
                i--;
                k = 2;
            } else if (dtw[d][i][j - 1][1] + cost === dtw[d][i][j][k]) {
                j--;
                k = 1;
            } else if (dtw[d][i - 1][j - 1][0] + cost === dtw[d][i][j][k]) {
                i--;
                j--;
                k = 0;
            } else if (d > 0 && k !== 1 && dtw[d - 1][i - 1][j][k] === dtw[d][i][j][k]) {
                d--;
                i--;
                matchPair = false;
                console.log('kill row1', i + 1)
            } else if (d > 0 && k !== 2 && dtw[d - 1][i][j - 1][k] === dtw[d][i][j][k]) {
                d--;
                j--;
                console.log('kill row1', j + 1)
                matchPair = false;
            } else {
                console.log('this is a bug')
                break;
            }
            if (matchPair) {
                pairs.push(pair)
            }
        }
        return {
            distance: dtw[deaths][NA][NB][0],
            pairs
        }
    }

    const range = root.select('.dtw-deaths');
    const drawCorrelation = (data1, data2, index1, index2, color, method) => {
        let indices = sd
            .getEventsDistance(data1, data2, d => d)
            .map((d, i) => ({ a: i, b: d }))

        if (method === 'dtw') {
            const deaths = +range.node().value;
            const result = buildMatchingEvents(deaths)
            indices = result.pairs
            console.log(result);
        } else if (method === 'dist_basic') {
            const matchBtoA = sd
                .getEventsDistance(data2, data1, d => d)
                .map((d, i) => ({ a: d, b: i }))
            indices = indices.concat(matchBtoA)
        }

        const distanceScale = d3.scaleLinear()
            .domain([0, bounds.width])
            .range([0, bounds.width])

        let arrows = svg.select('g.arrows')
        if (arrows.empty()) {
            arrows = svg.append('g')
                .attr('class', 'arrows')
        }

        const arrowSel = arrows.selectAll('line')
            .data(indices);

        arrowSel.enter()
            .append('line')
            .merge(arrowSel)
            .attr('x1', (d, i) => distanceScale(data1[d.a]))
            .attr('y1', getYMid(index1))
            .attr('x2', (d, i) => distanceScale(data2[d.b]))
            .attr('y2', getYMid(index2))
            .attr('stroke', color)
            .attr('stroke-width', 2);

        arrowSel.exit()
            .remove();

    }

    const register_button_handlers = () => {
        root.select('.match-a-to-b').on('click', function() {
            drawCorrelation(dataA, dataB, 0, 1, 'green')
        })
        root.select('.match-b-to-a').on('click', function() {
            drawCorrelation(dataB, dataA, 1, 0, 'red')
        })
        root.select('.match-both').on('click', function() {
            drawCorrelation(dataB, dataA, 1, 0, 'red', 'dist_basic')
        })
        range.attr('value', 0)
        root.select('.match-dtw').on('click', function() {
            dtw = sd.getDTWDistanceWithDeaths(dataA, dataB)
            drawCorrelation(dataA, dataB, 0, 1, 'red', 'dtw')
            range.attr('max', dataA.length + dataB.length)
        })

        range.on('click', function() {
            root.select('.death-count').html(this.value)
            drawCorrelation(dataA, dataB, 0, 1, 'red', 'dtw')
        })
    }

    register_button_handlers()

    generateChart('event1', dataA, { color: 'green' });
    generateChart('event2', dataB, { color: 'red', offsetY: getGroupOffset(1) });


</script>
</body>
</html>
